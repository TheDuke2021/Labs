//ВВП, Лабораторная работа номер 16, Бараев Дамир 201-725
//Программа написана на языке C++

#include <iostream>

using namespace std;

const double PI = 3.14;

char* locale = setlocale(LC_ALL, "");
void task_1();
void task_2();
void task_3();
void task_4();
void task_5();


int main()
{
	//Каждый task - это отдельное задание в лабораторной работе
	//Можно закомментировать нужные строчки, чтобы проверить 
	//работоспособность отдельно взятого задания
	task_1();
	//task_2();
	//task_3();
	//task_4();
	//task_5();
}

void task_1()
{

	//1. Дано целое число N (> 0). Сформировать и вывести целочисленный массив размера N, 
	//	содержащий N первых положительных нечетных чисел: 1, 3, 5, . . .

	int N;
	cout << "\nВведите N: " << endl;
	cin >> N;
	int *a = new int[N];
	int num = -1;
	for (int i = 0; i < N; i++)
		a[i] = num += 2;

	cout << "Массив:\n";

	for (int i = 0; i < N; i++)
		cout << a[i] << endl;

}

void task_2()
{

	//2. Описать функцию Sign(X) целого типа, возвращающую для вещественного числа X следующие значения:
	//	−1, если X < 0; 0, если X = 0; 1, если X > 0.
	//	С помощью этой функции найти значение выражения Sign(A) + Sign(B) для данных вещественных чисел A и B.


	

}

void task_3()
{
	//3. Описать функцию RingS(R1, R2) вещественного типа, находящую площадь кольца, заключенного между 
	//	двумя окружностями с общим центром и радиусами R1 и R2 (R1 и R2 — вещественные, R1 > R2). С ее 
	//	помощью найти площади трех колец, для которых даны внешние и внутренние радиусы.


}

void task_4()
{
	//4. Описать функцию Quarter(x, y) целого типа, определяющую номер координатной четверти, 
	//	в которой находится точка с ненулевыми вещественными координатами (x, y). С помощью 
	//	этой функции найти номера координатных четвертей для трех точек с данными ненулевыми координатами



}

void task_5()
{
	//5. Описать функцию Fact2(N) вещественного типа, вычисляющую двойной факториал: 
	//	N!!= 1·3·5·. ..·N, если N — нечетное;
	//	N!!= 2·4·6·. ..·N, если N — четное(N > 0 — параметр целого типа; вещественное возвращаемое значение 
	//	используется для того, чтобы избежать целочисленного переполнения при больших значениях N).


}